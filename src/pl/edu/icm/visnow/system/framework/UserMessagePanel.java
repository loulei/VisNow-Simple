//<editor-fold defaultstate="collapsed" desc=" License ">

/* VisNow
 Copyright (C) 2006-2013 University of Warsaw, ICM

 This file is part of GNU Classpath.

 GNU Classpath is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2, or (at your option)
 any later version.

 GNU Classpath is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with GNU Classpath; see the file COPYING.  If not, write to the
 University of Warsaw, Interdisciplinary Centre for Mathematical and
 Computational Modelling, Pawinskiego 5a, 02-106 Warsaw, Poland.

 Linking this library statically or dynamically with other modules is
 making a combined work based on this library.  Thus, the terms and
 conditions of the GNU General Public License cover the whole
 combination.

 As a special exception, the copyright holders of this library give you
 permission to link this library with independent modules to produce an
 executable, regardless of the license terms of these independent
 modules, and to copy and distribute the resulting executable under
 terms of your choice, provided that you also meet, for each linked
 independent module, the terms and conditions of the license of that
 module.  An independent module is a module which is not derived from
 or based on this library.  If you modify this library, you may extend
 this exception to your version of the library, but you are not
 obligated to do so.  If you do not wish to do so, delete this
 exception statement from your version. */
//</editor-fold>
package pl.edu.icm.visnow.system.framework;

import java.awt.Color;
import java.awt.Component;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.util.EventListener;
import java.util.EventObject;
import java.util.HashMap;
import java.util.Map;
import javax.swing.BorderFactory;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JTable;
import javax.swing.SwingUtilities;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableCellRenderer;
import pl.edu.icm.visnow.system.utils.usermessage.Level;
import pl.edu.icm.visnow.system.utils.usermessage.UserMessage;
import pl.edu.icm.visnow.system.utils.usermessage.UserMessageListener;
import static javax.swing.SwingConstants.LEFT;
import org.apache.log4j.Logger;
import pl.edu.icm.visnow.gui.icons.UIIconLoader;
import pl.edu.icm.visnow.gui.icons.UIIconLoader.*;
import pl.edu.icm.visnow.system.framework.UserMessageRow.ColumnName;

/**
 * Panel dedicated to show table of {@link UserMessage}(s).
 * It's tuned up to support expanding / collapsing of messages, autoscroll, customized view (icons, fonts, paddings, etc). Implements UserMessageListener, so it's
 * auto updated with currently arriving message.
 *
 * @author szpak
 */
public class UserMessagePanel extends javax.swing.JPanel implements UserMessageListener {

    private static final Logger LOGGER = Logger.getLogger(UserMessagePanel.class);
    //set to true if scroll goes to bottom, stays true if was true and scroll position hasn't changed
    //set to false if scrolled up by user (or position has changed in some other way)
    private boolean isAutoScrollToBottom = true;
    private int lastScrollPosition = 0;
    //widely used user table model
    DefaultTableModel tableModel;

    public UserMessagePanel() {
        initComponents();
        postInitComponents();
    
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        userMessagesSP = new javax.swing.JScrollPane();
        userMessageTable = new javax.swing.JTable();
        clearB = new javax.swing.JButton();
        closeB = new javax.swing.JButton();

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });
        setLayout(new java.awt.GridBagLayout());

        userMessagesSP.setAutoscrolls(true);
        userMessagesSP.setPreferredSize(new java.awt.Dimension(3, 200));

        userMessageTable.setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
        userMessageTable.setForeground(new java.awt.Color(102, 102, 102));
        userMessageTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {

            },
            new String [] {
                "", "Application", "Source", "Message"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        userMessageTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_ALL_COLUMNS);
        userMessageTable.setGridColor(new java.awt.Color(231, 231, 231));
        userMessageTable.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        userMessageTable.setShowHorizontalLines(false);
        userMessagesSP.setViewportView(userMessageTable);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(userMessagesSP, gridBagConstraints);

        clearB.setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
        clearB.setText("clear");
        clearB.setMargin(new java.awt.Insets(0, 10, 0, 10));
        clearB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                clearBActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 5, 3, 5);
        add(clearB, gridBagConstraints);

        closeB.setFont(new java.awt.Font("Dialog", 0, 11)); // NOI18N
        closeB.setText("close");
        closeB.setMargin(new java.awt.Insets(0, 10, 0, 10));
        closeB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                closeBActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 5, 3, 5);
        add(closeB, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Clears message table (clears table model)
     */
    private void clearBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_clearBActionPerformed
        //to avoid firing selection event
        userMessageTable.clearSelection();
        //clear table
        DefaultTableModel tm = ((DefaultTableModel) userMessageTable.getModel());
        int size = tm.getRowCount();
        for (int i = size - 1; i >= 0; i--)
            tm.removeRow(i);
    }//GEN-LAST:event_clearBActionPerformed

    /**
     * Notifies closeListener (if exists) about close action.
     *
     * @param evt
     */
    private void closeBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_closeBActionPerformed
        if (closeListener != null)
            closeListener.closeButtonAction(new EventObject(evt.getSource()));
    }//GEN-LAST:event_closeBActionPerformed

    /**
     * Scrolls message table to bottom; This is done by SwingUtils.invokeLater.
     */
    private void scrollToBottom() {
        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                //scroll to bottom
                userMessagesSP.getVerticalScrollBar().setValue(userMessagesSP.getVerticalScrollBar().getMaximum() - userMessagesSP.getVerticalScrollBar().getVisibleAmount());
            }
        });
    }

    /**
     * Tests if message table is scrolled to bottom
     */
    private boolean isAtBottom() {
        return userMessagesSP.getVerticalScrollBar().getValue() == userMessagesSP.getVerticalScrollBar().getMaximum() - userMessagesSP.getVerticalScrollBar().getVisibleAmount();
    }

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        //expand last message
        if (tableModel.getRowCount() > 0)
            messageToggle(tableModel.getRowCount() - 1, true);

        //and later scroll to bottom
        scrollToBottom();
    }//GEN-LAST:event_formComponentShown
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton clearB;
    private javax.swing.JButton closeB;
    private javax.swing.JTable userMessageTable;
    private javax.swing.JScrollPane userMessagesSP;
    // End of variables declaration//GEN-END:variables

    /**
     * Additional initialization of components that can't be made from NetBeans GUI including:
     * set custom table cell / header renderer, customize table / header view, add selection (onclick) handler for expand/collapse, add autoscroll functionality
     */
    private void postInitComponents() {

        tableModel = (DefaultTableModel) userMessageTable.getModel();

        //on click / selection listener - it's responsible for expanding/collapsing
        userMessageTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {
                //works only when user clicks/selects row (doesn't work when user unselect row)
                //only single selection is allowed
                if (!e.getValueIsAdjusting() && userMessageTable.getSelectedRowCount() == 1)
                    messageToggle(userMessageTable.getSelectedRow());
            }
        });

        //table cell renderer
        userMessageTable.setDefaultRenderer(Object.class, new DefaultTableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                UserMessageRow rowObject = (UserMessageRow)value;
                String stringValue = "";
                switch (UserMessageRow.getColumnName(column)) {
                    case LEVEL:
                        stringValue = rowObject.getLevel().name();
                        break;
                    case APPLICATION:
                        stringValue = rowObject.getApplicationName();
                        break;
                    case SOURCE:
                        stringValue = rowObject.getSourceName();
                        break;
                    case DESCRIPTION:
                        stringValue = rowObject.getDescription(rowObject.isExpanded(), true);
                        break;
                }
                super.getTableCellRendererComponent(table, stringValue, isSelected, hasFocus, row, column);

                //TODO: preinit colors + create color for selected
                if (!isSelected)
                    setBackground(row % 2 == 0 ? new Color(0xf7f7f7) : new Color(0xeeeeee));
                //TODO: common padding
                //inner padding
                setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));

                //alignment
                if (UserMessageRow.getColumnName(column) == ColumnName.LEVEL) { //center and set icon for Level column
                    setHorizontalAlignment(CENTER);
                    setText("");
                    Level level = rowObject.getLevel();
                    IconType iconType = IconType.INFO;
                    if (level == Level.ERROR) iconType = IconType.ERROR;
                    if (level == Level.WARNING) iconType = IconType.WARNING;

                    //TODO: optimize get font size (move to postInitComponents)
                    int size = userMessageTable.getFontMetrics(userMessageTable.getFont()).getHeight();
                    setIcon(UIIconLoader.getIcon(iconType, size, size));
                } else { //align to left and no icon for other columns
                    setIcon(null);
                    setHorizontalAlignment(LEFT);
                }
                setVerticalAlignment(TOP);

                //tool tip for message source, message content and application name
                switch (UserMessageRow.getColumnName(column)) {
                    case APPLICATION:
                    case SOURCE:
                        setToolTipText(value.toString());
                        break;
                    case DESCRIPTION:
                        setToolTipText(rowObject.getDescription(true, true));
                        break;
                    default:
                        setToolTipText(null); // or no tooltip
                }

                return this;
            }
        });

        //header renderer
        final TableCellRenderer headerRenderer = userMessageTable.getTableHeader().getDefaultRenderer();
        userMessageTable.getTableHeader().setDefaultRenderer(new TableCellRenderer() {
            @Override
            public Component getTableCellRendererComponent(JTable table, Object value, boolean isSelected, boolean hasFocus, int row, int column) {
                JLabel label = (JLabel) headerRenderer.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);
                label.setBorder(BorderFactory.createCompoundBorder(label.getBorder(), BorderFactory.createEmptyBorder(0, 2, 0, 2)));
                label.setHorizontalAlignment(LEFT);

                return label;
            }
        });


        //TODO: refactor colors (common colors)
        userMessageTable.getTableHeader()
                .setBackground(new Color(0xDDDDDD));

        //TODO: set header color to same as table color or similar + refactor header border (remove bevel?)



        userMessageTable.getTableHeader()
                .setReorderingAllowed(false);
        //TODO: refactor to common font
        userMessageTable.getTableHeader().setFont(userMessageTable.getFont());


        //set column widths
        Map<UserMessageRow.ColumnName, Integer> columnMaxWidths = new HashMap<UserMessageRow.ColumnName, Integer>();
        columnMaxWidths.put(UserMessageRow.ColumnName.LEVEL, 50);
        columnMaxWidths.put(UserMessageRow.ColumnName.APPLICATION, 200);
        columnMaxWidths.put(UserMessageRow.ColumnName.SOURCE, 200);
        columnMaxWidths.put(UserMessageRow.ColumnName.DESCRIPTION, 2000);

        for (Map.Entry<UserMessageRow.ColumnName, Integer> column : columnMaxWidths.entrySet())
            userMessageTable.getColumnModel().getColumn(UserMessageRow.getColumnIndex(column.getKey())).setMaxWidth(column.getValue());

        updateAllRowsHeight();

        //autoscroll to bottom
        userMessagesSP.getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {
            @Override
            public void adjustmentValueChanged(AdjustmentEvent e) {
                int position = userMessagesSP.getVerticalScrollBar().getValue();

                //set to true if scroll goes to bottom, stays true if was true and scroll position hasn't changed
                //set to false if scrolled up by user (or position has changed in some other way)
                isAutoScrollToBottom = isAtBottom() || (isAutoScrollToBottom && position == lastScrollPosition);
                lastScrollPosition = position;
            }
        });

    }

    /**
     * Updates panel when new message arrives: adds this message (collapsed) to list , scrolls down if necessary.
     *
     * @param message
     */
    @Override
    public void newMessage(final UserMessage message) {
        //create new row based on new message
        final UserMessageRow row = new UserMessageRow(message);

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                tableModel.addRow(row.toFakeRow());

                //update last row height (it's better to manually specify index to have proper row updated)
                updateRowHeights(tableModel.getRowCount() - 1);

                if (isAutoScrollToBottom) scrollToBottom();
            }
        });
    }

    /**
     * Toggles expanded mode of message at
     * <code>selectedIndex</code>.
     *
     * @param selectedIndex message index to expand/collapse
     */
    private void messageToggle(int selectedIndex) {
        messageToggle(selectedIndex, !((UserMessageRow)tableModel.getValueAt(selectedIndex, 0)).isExpanded());
    }

    /**
     * Sets expanded or collapsed mode of message at
     * <code>selectedIndes</code>.
     *
     * @param selectedIndex message index to expand/collapse
     */
    private void messageToggle(int selectedIndex, boolean expanded) {
        ((UserMessageRow)tableModel.getValueAt(selectedIndex, 0)).setExpanded(expanded);
        tableModel.fireTableRowsUpdated(selectedIndex, selectedIndex);
        
        //clears selection
        userMessageTable.clearSelection();
        
        updateRowHeights(selectedIndex);
        
        if (isAutoScrollToBottom) scrollToBottom();

        //TODO: check the flow
    }

    /**
     * Updates height of all table rows to fit whole content.
     */
    private void updateAllRowsHeight() {
        updateRowHeights(-1);
    }

    /**
     * Updates height of selected table row or all table rows to fit whole content.
     *
     * @param selectedRow row to update or -1 to update all
     */
    private void updateRowHeights(int selectedRow) {
        //by default all rows to update
        int startRow = 0;
        int endRow = userMessageTable.getRowCount() - 1;

        if (selectedRow != -1)
            endRow = startRow = selectedRow;

        for (int row = startRow; row <= endRow; row++) {
            int rowHeight = userMessageTable.getRowHeight();

            for (int column = 0; column < userMessageTable.getColumnCount(); column++) {
                Component comp = userMessageTable.prepareRenderer(userMessageTable.getCellRenderer(row, column), row, column);
                rowHeight = Math.max(rowHeight, comp.getPreferredSize().height);
            }

            userMessageTable.setRowHeight(row, rowHeight);
        }
    }

    /**
     * Listens to close button action.
     */
    public interface CloseListener extends EventListener {

        public void closeButtonAction(EventObject event);
    }
    private CloseListener closeListener = null;

    /**
     * Sets close listener. Only one listeners is supported and {@link UnsupportedOperationException} is thrown if second listener is added.
     * <code>addCloseListener</code> is used to have full support of event bindings in Netbeans design mode.
     *
     * @param listener
     */
    public void addCloseListener(CloseListener listener) {
        if (closeListener != null) throw new UnsupportedOperationException("Only one close listener is allowed");
        closeListener = listener;
    }

    public void removeCloseListener(CloseListener listener) {
        closeListener = null;
    }

    /**
     * Test frame
     *
     * @param args
     */
    public static void main(String[] args) {

        SwingUtilities.invokeLater(new Runnable() {
            @Override
            public void run() {
                JFrame f = new JFrame();
                f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                UserMessagePanel messagePanel = new UserMessagePanel();
                f.add(messagePanel);
                f.pack();
                f.setVisible(true);

                messagePanel.newMessage(new UserMessage("App 1", "image reader", "Image successfully loaded", "grapefruit.png <br> RGB, width: 100 weight: 200 <br> PNG 8 bit", Level.INFO));
                messagePanel.newMessage(new UserMessage("App 1", "DICOM reader", "cannot reconstruct volume due to sorting error!", "2 + 2 <> 4", Level.ERROR));
                messagePanel.newMessage(new UserMessage("Application 3", "image reader", "Image successfully loaded", "lena.jpg <br> RGB, width: 256 weight: 256 <br> JPEG", Level.INFO));
            }
        });
    }
}
