/* VisNow
   Copyright (C) 2006-2013 University of Warsaw, ICM

This file is part of GNU Classpath.

GNU Classpath is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GNU Classpath is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with GNU Classpath; see the file COPYING.  If not, write to the 
University of Warsaw, Interdisciplinary Centre for Mathematical and 
Computational Modelling, Pawinskiego 5a, 02-106 Warsaw, Poland. 

Linking this library statically or dynamically with other modules is
making a combined work based on this library.  Thus, the terms and
conditions of the GNU General Public License cover the whole
combination.

As a special exception, the copyright holders of this library give you
permission to link this library with independent modules to produce an
executable, regardless of the license terms of these independent
modules, and to copy and distribute the resulting executable under
terms of your choice, provided that you also meet, for each linked
independent module, the terms and conditions of the license of that
module.  An independent module is a module which is not derived from
or based on this library.  If you modify this library, you may extend
this exception to your version of the library, but you are not
obligated to do so.  If you do not wish to do so, delete this
exception statement from your version. */

package pl.edu.icm.visnow.gui.widgets;

import java.awt.Font;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Hashtable;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.SwingUtilities;
import javax.swing.WindowConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import org.apache.log4j.Logger;
import pl.edu.icm.visnow.lib.utils.SwingInstancer;
import pl.edu.icm.visnow.system.main.VisNow;

//TODO: - test if in EDT
//TODO: - synchronize(active)
/**
 * This is extended version of standard Slider with following features:
 * - additional input fields for min, max and current value (switchable with checkbox or hidden)
 * - slider label/tick marks.
 * 
 * This slider tries to be "smart" and it tries to: 
 * - label the slider with multiplicity of numbers like 1,2,5,10,20,50, and so on
 * - create proper corresponding tick marks
 * - makes each slider step of the same length (even if slider range is difficult to handle e.g. 
 *      7..10000  - this will be mapped to 0..10000 with step like 50 or 100).
 * - trims min and max to reflect min and max input by user.
 * 
 * @author Krzysztof S. Nowinski, University of Warsaw, ICM
 */
public class EnhancedVerticalIntSlider extends javax.swing.JPanel implements Serializable, MouseListener {

    private static final Logger LOGGER = Logger.getLogger(EnhancedVerticalIntSlider.class);
    protected int min = 0;
    protected int max = 100;
    protected int val = 20;
    protected int rMin = 0;
    protected int rMax = 100;
    protected int delta = 1;
    protected int l = 0;
    protected int u = 100;
    protected int ld = 10;
    protected int dec = 3;
    protected String form = "%" + dec + "d";
    protected String lform = "%" + (dec - 1) + "d";
    protected Font textFont = new java.awt.Font("Dialog", 0, 10);
    protected boolean active = true;
    protected boolean adjusting = true;
    protected boolean showingFields = true;
    private Hashtable<Integer, JLabel> labels = new Hashtable<Integer, JLabel>();

    /**
     * Creates new form IntegerSlider
     */
    public EnhancedVerticalIntSlider() {
        initComponents();
        for (int i = 0; i + l <= u; i += ld) {
            JLabel lbl = new JLabel(String.format(lform, rMin + i * delta));
            lbl.setFont(getFont());
            labels.put(new Integer(i + l), lbl);
        }
        slider.setLabelTable(labels);
        slider.addMouseListener(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        slider = new javax.swing.JSlider();
        maxField = new pl.edu.icm.visnow.gui.components.IntFormattedTextField();
        valField = new pl.edu.icm.visnow.gui.components.IntFormattedTextField();
        minField = new pl.edu.icm.visnow.gui.components.IntFormattedTextField();
        showFieldsBox = new javax.swing.JCheckBox();

        setFont(new java.awt.Font("Dialog", 0, 8)); // NOI18N
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });
        setLayout(new java.awt.GridBagLayout());

        slider.setFont(new java.awt.Font("Dialog", 0, 8)); // NOI18N
        slider.setMajorTickSpacing(100);
        slider.setMaximum(1000);
        slider.setMinorTickSpacing(20);
        slider.setOrientation(javax.swing.JSlider.VERTICAL);
        slider.setPaintLabels(true);
        slider.setPaintTicks(true);
        slider.setMinimumSize(new java.awt.Dimension(60, 80));
        slider.setPreferredSize(new java.awt.Dimension(60, 80));
        slider.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sliderStateChanged(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weighty = 1.0;
        add(slider, gridBagConstraints);

        maxField.setBackground(new java.awt.Color(238, 238, 238));
        maxField.setBorder(null);
        maxField.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        maxField.setText("100");
        maxField.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        maxField.setMinimumSize(new java.awt.Dimension(60, 14));
        maxField.setPreferredSize(new java.awt.Dimension(60, 14));
        maxField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                maxFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(maxField, gridBagConstraints);

        valField.setBorder(null);
        valField.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        valField.setText("50");
        valField.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        valField.setMinimumSize(new java.awt.Dimension(60, 14));
        valField.setPreferredSize(new java.awt.Dimension(60, 14));
        valField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                valFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(valField, gridBagConstraints);

        minField.setBackground(new java.awt.Color(238, 238, 238));
        minField.setBorder(null);
        minField.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        minField.setText("0");
        minField.setFont(new java.awt.Font("Dialog", 0, 10)); // NOI18N
        minField.setMinimumSize(new java.awt.Dimension(60, 14));
        minField.setPreferredSize(new java.awt.Dimension(60, 14));
        minField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                minFieldActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(minField, gridBagConstraints);

        showFieldsBox.setSelected(true);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("pl/edu/icm/visnow/gui/widgets/widgetstrings"); // NOI18N
        showFieldsBox.setToolTipText(bundle.getString("GUI.enhancedmodeCB.tooltip")); // NOI18N
        showFieldsBox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        showFieldsBox.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        showFieldsBox.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        showFieldsBox.setMargin(new java.awt.Insets(0, 0, 0, 0));
        showFieldsBox.setVerticalAlignment(javax.swing.SwingConstants.TOP);
        showFieldsBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                showFieldsBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        add(showFieldsBox, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

private void showFieldsBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_showFieldsBoxActionPerformed
    showingFields = showFieldsBox.isSelected();
    showFields();
}//GEN-LAST:event_showFieldsBoxActionPerformed

    /**
     * Sets valField for current value of val.
     */
    private void valFieldUpdate() {
        valField.setText(String.format(form, val));
    }

    /**
     * Sets maxField for current value of max.
     */
    private void maxFieldUpdate() {
        maxField.setText(String.format(form, max));
    }

    /**
     * Sets minField for current value of min.
     */
    private void minFieldUpdate() {
        minField.setText(String.format(form, min));
    }

private void valFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_valFieldActionPerformed
    LOGGER.trace("active: " + active);
    if (!active) return; //return if passive 

    //1. get value
    int valNew = Integer.parseInt(valField.getText());
    //2. call active setter (validate values, update controls, call listeners) 
    setVal(valNew, true);
}//GEN-LAST:event_valFieldActionPerformed

private void sliderStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sliderStateChanged
    LOGGER.trace("active: " + active);
    if (!active) return; //return if passive 

    //1. get value
    int valNew = 0;
    if (slider.getValue() == slider.getMinimum()) valNew = min;
    else if (slider.getValue() == slider.getMaximum()) valNew = max;
    else valNew = rMin + slider.getValue() * delta;

    LOGGER.trace("slider min/max/new: " + slider.getMinimum() + " " + slider.getMaximum() + " " + slider.getValue() + " min/max/cur/new: " + min + " " + max + " " + val + " :" + valNew);

    //2. call active setter (validate values, update controls, call listeners) 
    setVal(valNew, true);
}//GEN-LAST:event_sliderStateChanged

private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
//passive mode (assuming that roundMinMax and slider.setValue -> sliderStateChanged will not change val)
//TODO: test it
    active = false;
    sliderUpdateRange();
    slider.setValue((val - rMin) / delta);
    active = true;
}//GEN-LAST:event_formComponentResized

private void maxFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_maxFieldActionPerformed
{//GEN-HEADEREND:event_maxFieldActionPerformed
    LOGGER.trace("active: " + active);
    if (!active) return; //return if passive 

    //1. get value
    int maxNew = Integer.parseInt(maxField.getText());
    //2. call active setter (validate values, update controls, call listeners) 
    setMax(maxNew, true);
}//GEN-LAST:event_maxFieldActionPerformed

private void minFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_minFieldActionPerformed
{//GEN-HEADEREND:event_minFieldActionPerformed
    LOGGER.trace("active: " + active);
    if (!active) return; //return if passive 

    //1. get value
    int minNew = Integer.parseInt(minField.getText());
    //2. call active setter (validate values, update controls, call listeners) 
    setMin(minNew, true);
}//GEN-LAST:event_minFieldActionPerformed

    /**
     * Sets slider for current value of val.
     */
    private void sliderUpdateThumb() {
        LOGGER.trace("rmin/rmax/delta/value " + rMin + " " + rMax + " " + delta + " " + val);
        int sliderPos;
        if (val == max) sliderPos = slider.getMaximum();
        else if (val == min) sliderPos = slider.getMinimum();
        else sliderPos = Math.round((val - rMin) / delta);
        slider.setValue(sliderPos);
    }

    /**
     * Updates slider range/ticks/labels; Tries in smart way to: 
     * - label the slider with multiplicity of numbers like 1,2,5,10,20,50, and so on
     * - create proper corresponding tick marks
     * - makes each slider step of the same length (even if slider range is difficult to handle e.g 
     *      7..10000  - this will be mapped to 0..10000 with step like 50 or 100).
     * 
     * This method updates slider which results in sliderStateChanged.
     */
    private void sliderUpdateRange() {
        SwingInstancer.swingRun(new Runnable() {
            public void run() {
                double r = max - min;
                if (r <= 0)
                    r = 1;
                double logr = Math.log10(r);
                int iLogr = (int) (logr + 100) - 100;
                double mr = r / Math.pow(10., 1. * iLogr);
                int space = (slider.getHeight() - 30) / 20;
                if (space < 5)
                    space = 5;
                if (space > mr) {
                    mr *= 10;
                    iLogr -= 1;
                }
                mr /= space;
                if (mr < 2)
                    mr = 2;
                else if (mr < 5)
                    mr = 5;
                else
                    mr = 10;
                int d = (int) mr;
                if (iLogr > 0)
                    for (int i = 0; i < iLogr; i++)
                        d *= 10;
                if (iLogr < 0)
                    for (int i = 0; i > iLogr; i--)
                        d /= 10;
                if (d == 0) d = 1;
                int sMin = d * Math.round(min / d);
                if (sMin < min)
                    sMin += d;
                int sMax = d * Math.round(max / d);
                if (sMax > max)
                    sMax -= d;
                delta = d / ld;
                if (delta == 0)
                    delta = 1;
                rMin = delta * Math.round(min / delta);
                if (rMin > min)
                    rMin -= delta;
                rMax = delta * Math.round(max / delta);
                if (rMax < max)
                    rMax += delta;
                labels.clear();
                int lScale = (sMin - rMin) / delta;
                u = (rMax - rMin) / delta;
                logr = Math.log10(Math.max(Math.abs(sMin), Math.abs(sMax)));
                iLogr = (int) (logr + 100) - 100;
                if (iLogr > 0)
                    dec = iLogr + 2;
                else
                    dec = 2;
                dec = Math.max(Math.min(dec, 10),1);
                form = "%" + dec + "d";
                lform = "%" + (dec - 1) + "d";
                for (int i = 0; i + lScale <= u; i += ld) {
                    JLabel lbl = new JLabel(String.format(lform, sMin + i * delta));
                    lbl.setFont(EnhancedVerticalIntSlider.this.getFont());
                    labels.put(new Integer(i + (sMin - rMin) / delta), lbl);
                }
                if (labels.size() == 0) {
                    JLabel lbl = new JLabel(String.format(lform, rMin));
                    lbl.setFont(EnhancedVerticalIntSlider.this.getFont());
                    labels.put(0,lbl);
                }                                
                slider.setMaximum(u);
                slider.setLabelTable(labels);
                int ml = delta / 10;
                if (ml < 1)
                    ml = 1;
                slider.setMinorTickSpacing(ml);
                slider.repaint();
            }
        });
    }

    /**
     * Updates val to be in range [min;max].
     */
    private void validateValToRange() {
        if (val < min)
            val = min;
        if (val > max)
            val = max;
    }

    /**
     * Updates max to be >= min.
     */
    private void validateMaxToRange() {
        if (max < min)
            max = min;
    }

    /**
     * Updates min to be &lt;= max.
     */
    private void validateMinToRange() {
        if (min > max)
            min = max;
    }

    public int getMin() {
        return min;
    }

    /**
     * Passive setter for min value; new min value has to be less or equal to max
     * 1. switch to passive
     * 2. validates new min value and val value
     * 3. updates controls
     * 4. call fireStateChanged if necessary
     * 
     * @param minNew new value for min
     * @param onChangeEvent if true then fireStateChange is called on change.
     */
    private void setMin(int minNew, boolean onChangeEvent) {
        //1. switch to passive
        boolean prevActive = active;
        active = false; //passive update

        int minOld = min;
        int valOld = val;

        //2. validate and 3. update controls
        min = minNew;
        validateMinToRange();
        validateValToRange();

        sliderUpdateRange();
        sliderUpdateThumb();

//        if (min != minOld)
        minFieldUpdate(); //always update 
//        if (val != valOld)
        valFieldUpdate();

        active = prevActive;

        //4. call listeners    
        if (onChangeEvent && val != valOld)
            fireStateChanged();
    }

    /**
     * Passive setter - equivalent to setMin(valNew,false)
     */
    public void setMin(int minNew) {
        setMin(minNew, false);
    }

    public int getMax() {
        return max;
    }

    /**
     * Setter for max value; new max value has to be greater or equal to min
     * 1. switch to passive
     * 2. validates new max value and val value
     * 3. updates controls
     * 4. call fireStateChanged if necessary
     * 
     * @param maxNew new value for max
     * @param onChangeEvent if true then fireStateChange is called on change.
     */
    private void setMax(int maxNew, boolean onChangeEvent) {
        //1. switch to passive
        boolean prevActive = active;
        active = false; //passive update

        int maxOld = max;
        int valOld = val;

        //2. validate and 3. update controls
        max = maxNew;
        validateMaxToRange();
        validateValToRange();

        sliderUpdateRange();
        sliderUpdateThumb();

//        if (max != maxOld)
        maxFieldUpdate();
//        if (val != valOld)
        valFieldUpdate();

        active = prevActive;

        //4. call listeners    
        if (onChangeEvent && val != valOld)
            fireStateChanged();
    }

    /**
     * Passive setter - equivalent to setMax(valNew,false)
     */
    public void setMax(int maxNew) {
        setMax(maxNew, false);
    }

    /**
     * Passive setter for min and max values; min has to be less or equal to max
     * 1. switch to passive
     * 2. validates new min, max and val value
     * 3. updates controls
     * 
     * @param maxNew new value for max 
     * @param minNew new value for min 
     */
    private void setMinMax(int minNew, int maxNew, boolean onChangeEvent) {
        //1. switch to passive
        boolean prevActive = active;
        active = false; //passive update

        int minOld = min;
        int maxOld = max;
        int valOld = val;

        //2. validate and 3. update controls
        min = minNew;
        max = maxNew;
        validateMinToRange();
        validateMaxToRange();
        validateValToRange();

        sliderUpdateRange();
        sliderUpdateThumb();

//        if (min != minOld)
        minFieldUpdate();
//        if (max != maxOld)
        maxFieldUpdate();
//        if (val != valOld)
        valFieldUpdate();

        active = prevActive;

        //4. call listeners    
        if (onChangeEvent && val != valOld)
            fireStateChanged();
    }

    /**
     * Passive setter - equivalent to setMinMax(minNew,maxNew,false)
     */
    public void setMinMax(int minNew, int maxNew) {
        setMinMax(minNew, maxNew, false);
    }

    public int getVal() {
        return val;
    }

    /**
     * Setter for val value; new val value has to be in [min..max] range
     * 1. switch to passive
     * 2. validates new val value
     * 3. updates controls
     * 4. call fireStateChanged if necessary
     * 
     * @param valNew new value for val
     * @param onChangeEvent if true then fireStateChange is called on change.
     */
    private void setVal(int valNew, boolean onChangeEvent) {
        LOGGER.trace("valNew/onChange: " + valNew + " " + onChangeEvent + " isEventDispatchThread: " + SwingUtilities.isEventDispatchThread());
        //1. switch to passive
        boolean prevActive = active;
        active = false; //passive update

        int valOld = val;

        //2. validate and 3. update controls
        val = valNew;
        validateValToRange();

        sliderUpdateThumb();

//        if (val != valOld)
        valFieldUpdate();

        active = prevActive;

        //4. call listeners    
        //always call listeners (e.g. onMouseUp)
        if (onChangeEvent)// && val != valOld) 
            fireStateChanged();
    }

    /**
     * Passive setter - equivalent to setVal(valNew,false)
     * @param valNew 
     */
    public void setVal(int valNew) {
        setVal(valNew, false);
    }

    public int getDec() {
        return dec;
    }

    public void setDec(int dec) {
        this.dec = dec;
    }

    public void setTextFont(Font textFont) {
        this.textFont = textFont;
        maxField.setFont(textFont);
        valField.setFont(textFont);
        minField.setFont(textFont);
    }

    public boolean isAdjusting() {
        return slider.getValueIsAdjusting();
    }

    public void setAdjusting(boolean adjusting) {
        this.adjusting = adjusting;
        slider.setValueIsAdjusting(adjusting);
    }

    public boolean isShowingFields() {
        return showingFields;
    }

    public void setShowingFields(boolean showingFields) {
        this.showingFields = showingFields;
        showFieldsBox.setSelected(showingFields);
        showFields();
    }

    public void showFields() {
        minField.setVisible(showingFields);
        maxField.setVisible(showingFields);
        valField.setVisible(showingFields);
        this.validate();
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private pl.edu.icm.visnow.gui.components.IntFormattedTextField maxField;
    private pl.edu.icm.visnow.gui.components.IntFormattedTextField minField;
    private javax.swing.JCheckBox showFieldsBox;
    private javax.swing.JSlider slider;
    private pl.edu.icm.visnow.gui.components.IntFormattedTextField valField;
    // End of variables declaration//GEN-END:variables
    /**
     * Utility field holding list of ChangeListeners.    
     */
    private transient ArrayList<ChangeListener> changeListenerList = new ArrayList<ChangeListener>();

    /**
     * Registers ChangeListener to receive events.
     *
     * @param listener The listener to register.
     */
    public synchronized void addChangeListener(ChangeListener listener) {
        changeListenerList.add(listener);
    }

    /**
     * Removes ChangeListener from the list of listeners.
     *
     * @param listener The listener to remove.
     */
    public synchronized void removeChangeListener(ChangeListener listener) {
        if (changeListenerList != null) {
            changeListenerList.remove(listener);
        }
    }

    /**
     * Notifies all registered listeners about the event.
     *
     * @param object Parameter #1 of the <CODE>ChangeEvent<CODE> constructor.
     */
    private void fireStateChanged() {
        LOGGER.trace("Active: " + (!((slider.getValueIsAdjusting() && !adjusting) || !active)) + " value: " + val);
        if ((slider.getValueIsAdjusting() && !adjusting) || !active)
            return;
        java.util.ArrayList list;
        ChangeEvent e = new ChangeEvent(this);
        synchronized (this) {
            if (changeListenerList == null)
                return;
            list = new ArrayList<ChangeListener>(changeListenerList);
        }
        for (int i = 0; i < list.size(); i++) {
            ((ChangeListener) list.get(i)).stateChanged(e);
        }
    }

    @Override
    public void setEnabled(boolean enabled) {
        slider.setEnabled(enabled);
        valField.setEnabled(enabled);
        maxField.setEnabled(enabled);
        minField.setEnabled(enabled);
        showFieldsBox.setEnabled(enabled);
    }
    /**
     * Utility field holding list of MouseListeners.
     */
    private transient ArrayList<MouseListener> mouseListenerList = new ArrayList<MouseListener>();

    /**
     * Registers MouseListener to receive events.
     *
     * @param listener The listener to register.
     */
    @Override
    public synchronized void addMouseListener(MouseListener listener) {
        mouseListenerList.add(listener);
    }

    /**
     * Removes MouseListener from the list of listeners.
     *
     * @param listener The listener to remove.
     */
    @Override
    public synchronized void removeMouseListener(MouseListener listener) {
        if (mouseListenerList != null) {
            mouseListenerList.remove(listener);
        }
    }

    public void mouseClicked(MouseEvent e) {
        for (MouseListener listener : mouseListenerList)
            listener.mouseClicked(e);
    }

    public void mousePressed(MouseEvent e) {
        for (MouseListener listener : mouseListenerList)
            listener.mousePressed(e);
    }

    public void mouseReleased(MouseEvent e) {
        for (MouseListener listener : mouseListenerList)
            listener.mouseReleased(e);
    }

    public void mouseEntered(MouseEvent e) {
        for (MouseListener listener : mouseListenerList)
            listener.mouseEntered(e);

    }

    public void mouseExited(MouseEvent e) {
        for (MouseListener listener : mouseListenerList)
            listener.mouseExited(e);
    }

    public static void main(String[] a) {
        JFrame f = new JFrame();
        VisNow.initLogging(true);
        final EnhancedVerticalIntSlider eis = new EnhancedVerticalIntSlider();
        eis.addChangeListener(new ChangeListener() {
            @Override
            public void stateChanged(ChangeEvent e) {
                LOGGER.trace("" + eis.getVal());
            }
        });
        f.add(eis);
        f.setLocation(600, 300);
        f.pack();
        f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        f.setVisible(true);
    }
}
